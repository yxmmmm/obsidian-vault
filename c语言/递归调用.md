## eg1阶乘
```c
long long fact(int n)
{
    long long int t;
    if(n==0)
        t=1;
	else
	t=fact(n-1)*n;
	return t;
}
```
注：迭代不占内存空间，递归一直占用很大内存
## ​eg2汉诺塔
![image.png](https://tuchuang-1387570672.cos.ap-nanjing.myqcloud.com/obsidianvault20251121184000.png)
```c
void hanoi(int n,char A,char B,char C){
    if(n==1)
    printf("%c->%c\n",A,C);//递归终止
    else
    {
    hanoi(n-1,A,C,B);//上面n-1个圆盘由A到B
    printf("%c->%c",A,C);//第n个由A到C
    hanoi(n-1,B,A,C);//上面n-1个由B到C
    }
}
#include<stdio.h>
int main(void)
{
    int n;
    scanf("%d",&n);
    hanoi(n,'A','B','C');
    return 0;
}
```

---
# 递归思想进化

eg.本题要求实现一个函数，用下列公式求cos(x)的近似值，精确到最后一项的绝对值小于e：

cos(x)=x0/0!−x2/2!+x4/4!−x6/6!+⋯

### 函数接口定义：

```c++
double funcos( double e, double x );
```

其中用户传入的参数为误差上限`e`和自变量`x`；函数`funcos`应返回用给定公式计算出来、并且满足误差要求的cos(x)的近似值。输入输出均在双精度范围内。

#### 注意：此处需要用到阶乘函数但却无法声明，因此不可定义阶乘函数
***此处用到递归思想***
##### 关键发现：后一项可以从前一项简单得到

比如：

- 第0项是 `1`
    
- 第1项 = 第0项 × `(-x²)/(1×2)`
    
- 第2项 = 第1项 × `(-x²)/(3×4)`
    
- 第3项 = 第2项 × `(-x²)/(5×6)`
    

**通用规律：**

text

下一项 = 当前项 × (-x²) / [(当前编号×2-1) × (当前编号×2)]

==实践！！==
```c
double funcos( double e, double x ){
    double term = 1,sum = 1;
    for(int i = 2; fabs(term) >= e; i++){//用到绝对值函数fabs（
        term = -term*(x*x/((2*i-3)*(2*i-2)));
        sum += term;
    }
    return sum;
}
```
