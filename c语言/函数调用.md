## 函数中调用其他函数
1. 被调函数存在
2. 调用库函数，使用#include
3. 被调函数自定义，则需进行[[声明]]
## eg.哥德巴赫猜想
已知任意一个大于2的偶数可写成两个素数之和
### part1判断素数
```c
#include<stdio.h>
#include<math.h>
int prime(int n){
int i;
if(n<=1);
return 0;
for(i=2;i<sqrt(n);i++){
    if(n%i==0)
    return 0;
    }
return 1;    
}
```
### part2 Goldbach函数
```c
void goldbach(int n){
int i;
for(i=3;i<=n/2;i++){
    if(prime(i)&&prime(n-1)){
    printf("%d=%d+%d",n,i,n-i);
    break;}
    }
}
```
### part3主函数
```c
int main(void){
    int i;
    for(i=4;i<=2000;i+=2)
    goldbach(i);
    return 0;
}
```
![image.png|500](https://tuchuang-1387570672.cos.ap-nanjing.myqcloud.com/obsidianvault20251121170758.png)

## eg2计算组合数
![image.png](https://tuchuang-1387570672.cos.ap-nanjing.myqcloud.com/obsidianvault20251121175247.png)
解题关键
1. 定义fun函数，返回参数n阶乘
2. 主函数调用fun(n)/(fun(n)* fun(n-m))
```c
long long fun(int n)
{
  int i,jie=1;
  for(i=1;i<=n;i++)
  j*=i;
  return j;
}
int main(void)
{
    int n,m,c;
    scanf("%d %d",&n,&m);
    c=fun(n)/(fun(n)* fun(n-m))
    printf("%d",c);
    return 0;
}
```
但此时健壮性不足，n< m时输出结果为0
应有判断大小mn大小代码块
```c
long long fun(int n)
{
  int i,jie=1;
  for(i=1;i<=n;i++)
  j*=i;
  return j;
}
int main(void)
{
    int n,m,c;
    scanf("%d %d",&n,&m);
    while(1)//判断语句
    {
    if(n<m)
      {
      printf("输入有误重新输入")；
      scanf("%d %d",&n,&m);
      }
      else
      break;
    }
    c=fun(n)/(fun(n)* fun(n-m))
    printf("%d",c);
    return 0;
}
```
# 递归调用
## eg1阶乘
```c
long long fact(int n)
{
    long long int t;
    if(n==0)
        t=1;
	else
	t=fact(n-1)*n;
	return t;
}
```
注：迭代不占内存空间，递归一直占用很大内存
## ​eg2汉诺塔
![image.png](https://tuchuang-1387570672.cos.ap-nanjing.myqcloud.com/obsidianvault20251121184000.png)
```c
void hanoi(int n,char A,char B,char C){
    if(n==1)
    printf("%c->%c\n",A,C);//递归终止
    else
    {
    hanoi(n-1,A,C,B);//上面n-1个圆盘由A到B
    printf("%c->%c",A,C);//第n个由A到C
    hanoi(n-1,B,A,C);//上面n-1个由B到C
    }
}
#include<stdio.h>
int main(void)
{
    int n;
    scanf("%d",&n);
    hanoi(n,'A','B','C');
    return 0;
}
```

