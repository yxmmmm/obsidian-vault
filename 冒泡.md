# 1大数移至最后
# 2相互比较
![Pasted image 20251114170012](https://tuchuang-1387570672.cos.ap-nanjing.myqcloud.com/obsidianvaultPasted%20image%2020251114170012.png)
# 3整体进行次数
现在研究一下，“把数值最大的挪到最后”这个操作要执行几次：
如果数组只有1个元素，就不用排序了
如果数组有2个元素，挪数的操作需要1次
如果数组有3个元素，挪数的操作需要2次
如果数组有4个元素，挪数的操作需要3次
……
可以推出：如果数组有n个元素，挪数的操作需要==n-1==次。
同时第i轮中需要比较==n-i==次
![Pasted image 20251114170100](https://tuchuang-1387570672.cos.ap-nanjing.myqcloud.com/obsidianvaultPasted%20image%2020251114170100.png)
# 4演示
```c
#include<stdio.h>

int main(){

int i,j;

int a[5];

for(i=0;i<5;i++){

scanf("%d",&a[i]);

}

int temp;

for(i=1;i<=5;i++){//n-1组

for(j=0;j<5-i;j++){//第i轮中n-i次

if(a[j]<a[j+1]){

temp=a[j];

a[j]=a[j+1];

a[j+1]=temp;

}

}

}

for(i=0;i<5;i++){

printf("%d",a[i]);

}

return 0;

}
```
